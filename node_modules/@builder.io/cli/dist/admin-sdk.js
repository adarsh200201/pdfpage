"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.newSpace = exports.importSpace = void 0;
const createClient_1 = require("./autogen/client/createClient");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const chalk_1 = __importDefault(require("chalk"));
const utils_1 = require("./utils");
const cli_progress_1 = __importDefault(require("cli-progress"));
const crypto_1 = require("crypto");
const traverse_1 = __importDefault(require("traverse"));
const MULTIBAR = new cli_progress_1.default.MultiBar({
    clearOnComplete: false,
    hideCursor: true,
    format: '|{bar}| {name} | {value}/{total}',
}, cli_progress_1.default.Presets.shades_grey);
const root = 'https://cdn.builder.io';
const createGraphqlClient = (privateKey) => createClient_1.createClient({
    fetcher: ({ query, variables }, fetch, qs) => fetch(`${root}/api/v2/admin`, {
        method: 'POST',
        body: JSON.stringify({ query, variables }),
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${privateKey}`,
        },
    }).then(r => r.json()),
});
exports.importSpace = (privateKey, directory, debug = false, limit = 100, offset = 0) => __awaiter(void 0, void 0, void 0, function* () {
    const graphqlClient = createGraphqlClient(privateKey);
    const spaceProgress = MULTIBAR.create(1, 0);
    spaceProgress.start(1, 0, { name: 'getting space settings' });
    try {
        const space = yield graphqlClient.chain.query
            .downloadClone({
            contentQuery: {
                limit,
                offset,
            },
        })
            .execute({
            models: { name: true, everything: true, content: true },
            settings: true,
            meta: true,
        });
        spaceProgress.setTotal(space.models.length);
        yield fs_extra_1.default.outputFile(`${directory}/settings.json`, JSON.stringify(Object.assign(Object.assign({}, space.settings), { cloneInfo: space.meta }), undefined, 2));
        const modelOps = space.models.map((model, index) => __awaiter(void 0, void 0, void 0, function* () {
            const { content, everything } = model;
            // todo why conent is in everything
            const { content: _ } = everything, schema = __rest(everything, ["content"]);
            const modelName = lodash_1.kebabCase(model.name);
            yield fs_extra_1.default.emptyDir(`${directory}/${modelName}`);
            const modelProgress = MULTIBAR.create(content.length, 0, { name: modelName });
            if (content.length > 0) {
                modelProgress.start(content.length, 0);
            }
            yield fs_extra_1.default.outputFile(`${directory}/${modelName}/schema.model.json`, JSON.stringify(schema, null, 2));
            yield Promise.all(content.map((entry, index) => __awaiter(void 0, void 0, void 0, function* () {
                const filename = `${directory}/${modelName}/${lodash_1.kebabCase(entry.name)}-${index}.json`;
                yield fs_extra_1.default.outputFile(filename, JSON.stringify(entry, undefined, 2));
                modelProgress.increment(1, { name: ` ${modelName}: ${filename} ` });
            })));
            spaceProgress.increment();
            modelProgress.stop();
        }));
        yield Promise.all(modelOps);
        if (debug) {
            console.log(chalk_1.default.green('Imported successfully ', space.settings.name));
        }
    }
    catch (e) {
        console.log(`\r\n\r\n`);
        console.error(chalk_1.default.red('Error importing space'));
        console.error(e);
        process.exit();
    }
    spaceProgress.stop();
    MULTIBAR.stop();
});
exports.newSpace = (privateKey, directory, name, debug = false) => __awaiter(void 0, void 0, void 0, function* () {
    const graphqlClient = createGraphqlClient(privateKey);
    const spaceSettings = yield utils_1.readAsJson(`${directory}/settings.json`);
    try {
        const { organization, privateKey: newSpacePrivateKey } = yield graphqlClient.chain.mutation
            .createSpace({
            settings: Object.assign(Object.assign({}, lodash_1.omit(spaceSettings, 'cloneInfo')), { name: name || spaceSettings.name }),
        })
            .execute();
        const newSpaceAdminClient = createGraphqlClient(newSpacePrivateKey.key);
        const spaceModelIdsMap = Object.values(spaceSettings.cloneInfo.modelIdMap).reduce((modelMap, id) => (Object.assign(Object.assign({}, modelMap), { [id]: crypto_1.createHash('sha256')
                .update(id + organization.id)
                .digest('hex') })), {});
        const spaceContentIdsMap = Object.values(spaceSettings.cloneInfo.contentIdMap).reduce((contenIdMap, id) => (Object.assign(Object.assign({}, contenIdMap), { [id]: crypto_1.createHash('sha256')
                .update(id + organization.id)
                .digest('hex') })), {});
        const replaceIds = (obj) => traverse_1.default(obj).map(function (field) {
            var _a;
            // we keep meta props as is for debugging puprposes
            if ((_a = this.key) === null || _a === void 0 ? void 0 : _a.includes('@')) {
                return;
            }
            if (spaceModelIdsMap[field]) {
                this.update(spaceModelIdsMap[field]);
            }
            else if (spaceContentIdsMap[field]) {
                this.update(spaceContentIdsMap[field]);
            }
        });
        const models = yield utils_1.getDirectories(`${directory}`);
        const modelsPromises = models.map(({ name: modelName }) => __awaiter(void 0, void 0, void 0, function* () {
            const body = utils_1.replaceField(yield utils_1.readAsJson(`${directory}/${modelName}/schema.model.json`), organization.id, spaceSettings.id);
            const model = yield newSpaceAdminClient.chain.mutation
                .addModel({ body: replaceIds(body) })
                .execute({ id: true, name: true });
            if (model) {
                const content = (yield utils_1.getFiles(`${directory}/${modelName}`)).filter(file => file.name !== 'schema.model.json');
                const modelProgress = MULTIBAR.create(content.length, 0, { name: modelName });
                if (content.length > 0) {
                    modelProgress.start(content.length, 0, { name: modelName });
                }
                const writeApi = `https://builder.io/api/v1/write/${modelName}`;
                const contentPromises = content.map((contentFile, index) => __awaiter(void 0, void 0, void 0, function* () {
                    let contentJSON = replaceIds(utils_1.replaceField(yield utils_1.readAsJson(`${directory}/${modelName}/${contentFile.name}`), organization.id, spaceSettings.id));
                    modelProgress.increment(1, {
                        name: `${modelName}: writing ${contentFile.name}`,
                    });
                    // post content to write api using the new space private api key
                    yield fetch(writeApi, {
                        method: 'POST',
                        body: JSON.stringify(contentJSON),
                        headers: {
                            'Content-Type': 'application/json',
                            Authorization: `Bearer ${newSpacePrivateKey.key}`,
                        },
                    });
                }));
                yield Promise.all(contentPromises);
                modelProgress.stop();
            }
        }));
        yield Promise.all(modelsPromises);
        if (debug) {
            console.log(`\r\n\r\n`);
            console.log(chalk_1.default.green(`Your new space "${organization.name}" public API Key: ${organization.id}`));
            console.log(`\r\n\r\n`);
        }
    }
    catch (e) {
        console.log(`\r\n\r\n`);
        console.error(chalk_1.default.red('Error creating space'));
        console.error(e);
        process.exit();
    }
    MULTIBAR.stop();
});
